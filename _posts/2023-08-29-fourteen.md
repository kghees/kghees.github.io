---
layout: single
title:  "[BOJ/백준] 골드4 17298번 오큰수."
categories: CodingTest
tag: [Algorithm, python]
toc: true
author_profile: false
sidebar:
    nav: "counts"
---

# 출처
<https://www.acmicpc.net/problem/17298>


# 문제
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.


## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

## 출력
총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.

![image](https://github-production-user-asset-6210df.s3.amazonaws.com/92205960/263895152-171b5621-23c2-47eb-9179-fdccd9b35c83.png)


# 과정
처음에는 단순히 이중 list값들의 크기를 이중 for문을 써서 하나하나 비교해서
큰 값이 나오면 stack에 저장한 후  stack에 
# 정답 코드
<script src="https://gist.github.com/kghees/5e99c07f2872efa79c7fd37c07ca74d2.js"></script>

# 시행 착오
처음에는 단순히 이중 list값들의 크기를 이중 for문을 써서 하나하나 비교해서
큰 값이 나오면 stack에 저장한 후  stack에 첫번째 값을 정답 리스트에 넣어주면
된다고 생각했고 마지막 값은 어차피 -1이 나오므로 마지막 전까지 계산 한 후 
정답리스트 마지막에 -1를 추가해주는 식으로 풀게 되었는데 이렇게 푼다면
마지막말고 중간이나 처음에 제일 큰 값이 있어 버리면 -1을 넣어 줄 수 없었다.
그래서 고민해보다가 


# 후기
시간제한을 잘 보고 시간복잡도 계산을 해보는 것도 중요한 거 같다.


